from math import factorial


"""
СОЧЕТАНИЯ
    -   это набор, состоящий из k  элементов, выбранных  из множества, содержащего n  различных элементов. 
    В сочетаниях неважен порядок. Например, когда вы играете в карты, у вашего соперника 6 карт. 
    Вас не интересует, в какой последовательности он их держит, а вас интересует только их содержание: какие масти, есть ли тузы и т.д.
    Формула для расчета числа сочетаний:

    (C_n ^k) = n! / (k! * (n - k)!)
"""
def combcombinatorics_combination(k, n):
    return factorial(n) / (factorial(k) * factorial(n - k))




"""
ФОРМУЛА БЕРНУЛИ
    Мы говорим, что случайная дискретная величина Х имеет биномиальное распределение с переменными k,n и p,  
    если  вероятность ее распределения задается следующим уравнением:

    P(X=k) = (C_n ^k) *(p^k) *(q^(n-k))

	k ,число наступления события (дискретная величина из отрезка [0, n])
	n -  число испытаний 
	p - вероятность наступления события A в  независимых испытаниях, 
	q = 1 – p. Противоположная вероятность

    Выше приведенная формула для вычисления вероятностей наступления события k раз из n и есть формула Бернулли.
"""

def binomial_distribution(k, n, p):
    q = 1 - p
    return combcombinatorics_combination(k, n) * (p**k) * (q**(n-k))



"""
Распределение Пуассона
    В том случае, если вероятность наступления события очень маленькая  (< 0.1), а число испытаний очень большое,
    применяется формула Пуассона. 
    Распределение Пуассона это также дискретное распределение и является частным случаем биномиального распределения.
    Чтобы найти вероятность наступления события за фиксированную единицу измерения или вероятность, 
    что событие наступит m раз из n, применяем формулу Пуассона. 
    Эта формула дает более точные значения вероятности в такой ситуации.
    
    (P_m) ≈ ((λ^m) / m!) * (e^(-λ))

    Здесь появляется величина λ. Это средняя интенсивность наступления события на некоторую единицу измерения. 
    Например, число ошибок на разворот, вкраплений/ м^2, потребителей/час.
"""
def puasson_distributio(λ, m, e):
    return pow(λ, m) / factorial(m) * pow(e, -λ)